<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.Scheduler.RandomScheduling API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Scheduler.RandomScheduling</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import time
from typing import Set
from cryptography.fernet import Fernet


# This lock is used to get access to print onto the standard output
from Locks.MasterPrintLock import master
from Communication.protocol import YACS_Protocol
from Scheduler.JobRequests import JobRequestHandler
from MasterUtils.WorkerStateTracker import StateTracker


class RandomScheduler:
    &#34;&#34;&#34; The ```RandomScheduler``` class implements the **Random Scheduling**
    algorithm. In this algorithm the Master chooses a machine at random.
    It then checks if the machine has free slots available. If yes, it
    launches the task on the machine. Else, it chooses another machine at
    random. This process continues until a free slot is found.
    &#34;&#34;&#34;
    @staticmethod
    def jobDispatcher(requestHandler: JobRequestHandler,
                      workerStateTracker: StateTracker):
        &#34;&#34;&#34;```jobDispatcher``` implements the **Random Scheduling** algorithm

        **param** ```requestHandler```: This object will track the tasks of
        incomplete jobs, and provide them for allocation, respecting the
        *map-reduce* dependency

        **type** ```requestHandler```: JobRequestHandler

        **param** ```workerStateTracker```: This object will track and update
        how loaded the workers are, i.e. how many free slots fo they have

        **type** ```workerStateTracker```: StateTracker
        &#34;&#34;&#34;
        #  Initialize the random number generator.
        random.seed()
        workerIDsVisited: Set = set()

        while True:
            jobID_family_task = None

            # Get a pending task, if any
            requestHandler.LOCK.acquire()
            if not requestHandler.isEmpty():
                jobID_family_task = requestHandler.getWaitingTask()
            requestHandler.LOCK.release()

            # If there is a Task that needs to be executed
            if jobID_family_task is not None:
                # Initially we have not visited any worker
                workerIDsVisited.clear()

                # Initially we have not found a worker with a free slot
                workerFound: bool = False

                while workerFound is False:  # Until a free worker is not found
                    workerStateTracker.LOCK.acquire()

                    # Pick a worker at random
                    _temp = random.choice(workerStateTracker.workerIDs)
                    workerIDsVisited.add(_temp)

                    # If the worker has a free slot
                    if workerStateTracker.isWorkerFree(_temp):
                        # Create the JSON protocol message
                        protocolMsg = (YACS_Protocol
                                       .createMessageToWorker
                                       (
                                        job_ID=jobID_family_task[0],
                                        task_family=jobID_family_task[1],
                                        task_ID=(jobID_family_task[2]
                                                 [&#34;task_id&#34;]),
                                        duration=(jobID_family_task[2]
                                                  [&#34;duration&#34;]),
                                        # We only get _temp in the LOCK
                                        # i.e. critical section
                                        worker_ID=_temp
                                        ))
                        # Once a worker with a free slot is found then
                        # 1. We dispatch the job to the worker
                        # 2. Update its state
                        enc_obj = Fernet(workerStateTracker
                                         .workerState[_temp][&#34;pri_key&#34;])
                        workerStateTracker.getWorkerSocket(_temp)\
                            .sendall(enc_obj.encrypt(protocolMsg.encode()))

                        master.PRINT_LOCK.acquire()
                        print(f&#34;Sending task to worker: {protocolMsg}&#34;)
                        master.PRINT_LOCK.release()

                        workerStateTracker.allocateSlot(_temp)

                        master.PRINT_LOCK.acquire()
                        workerStateTracker.showWorkerStates()
                        master.PRINT_LOCK.release()

                        master.PRINT_LOCK.acquire()
                        print(f&#34;{requestHandler.jobRequests=}&#34;)
                        master.PRINT_LOCK.release()

                        # We have found a worker and hence set this to True
                        workerFound = True

                    workerStateTracker.LOCK.release()

                    # In the case where none of the workers have a free slot
                    if list(workerIDsVisited) == workerStateTracker.workerIDs:
                        # Sleep for a second to allow for the
                        # workerStateTracker to be updated by the
                        # thread: workerUpdates
                        time.sleep(1)

                        # Clear the worker IDs visited set as we are
                        # restarting our search for a free slot on one of the
                        # workers
                        workerIDsVisited.clear()

                # After sending a task to the worker, sleep for 0.01 seconds
                # before sending the next task. This done so that the worker
                # buffer only has at most 1 task in its socket&#39;s buffer
                # time.sleep(0.01)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Scheduler.RandomScheduling.RandomScheduler"><code class="flex name class">
<span>class <span class="ident">RandomScheduler</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code>RandomScheduler</code> class implements the <strong>Random Scheduling</strong>
algorithm. In this algorithm the Master chooses a machine at random.
It then checks if the machine has free slots available. If yes, it
launches the task on the machine. Else, it chooses another machine at
random. This process continues until a free slot is found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomScheduler:
    &#34;&#34;&#34; The ```RandomScheduler``` class implements the **Random Scheduling**
    algorithm. In this algorithm the Master chooses a machine at random.
    It then checks if the machine has free slots available. If yes, it
    launches the task on the machine. Else, it chooses another machine at
    random. This process continues until a free slot is found.
    &#34;&#34;&#34;
    @staticmethod
    def jobDispatcher(requestHandler: JobRequestHandler,
                      workerStateTracker: StateTracker):
        &#34;&#34;&#34;```jobDispatcher``` implements the **Random Scheduling** algorithm

        **param** ```requestHandler```: This object will track the tasks of
        incomplete jobs, and provide them for allocation, respecting the
        *map-reduce* dependency

        **type** ```requestHandler```: JobRequestHandler

        **param** ```workerStateTracker```: This object will track and update
        how loaded the workers are, i.e. how many free slots fo they have

        **type** ```workerStateTracker```: StateTracker
        &#34;&#34;&#34;
        #  Initialize the random number generator.
        random.seed()
        workerIDsVisited: Set = set()

        while True:
            jobID_family_task = None

            # Get a pending task, if any
            requestHandler.LOCK.acquire()
            if not requestHandler.isEmpty():
                jobID_family_task = requestHandler.getWaitingTask()
            requestHandler.LOCK.release()

            # If there is a Task that needs to be executed
            if jobID_family_task is not None:
                # Initially we have not visited any worker
                workerIDsVisited.clear()

                # Initially we have not found a worker with a free slot
                workerFound: bool = False

                while workerFound is False:  # Until a free worker is not found
                    workerStateTracker.LOCK.acquire()

                    # Pick a worker at random
                    _temp = random.choice(workerStateTracker.workerIDs)
                    workerIDsVisited.add(_temp)

                    # If the worker has a free slot
                    if workerStateTracker.isWorkerFree(_temp):
                        # Create the JSON protocol message
                        protocolMsg = (YACS_Protocol
                                       .createMessageToWorker
                                       (
                                        job_ID=jobID_family_task[0],
                                        task_family=jobID_family_task[1],
                                        task_ID=(jobID_family_task[2]
                                                 [&#34;task_id&#34;]),
                                        duration=(jobID_family_task[2]
                                                  [&#34;duration&#34;]),
                                        # We only get _temp in the LOCK
                                        # i.e. critical section
                                        worker_ID=_temp
                                        ))
                        # Once a worker with a free slot is found then
                        # 1. We dispatch the job to the worker
                        # 2. Update its state
                        enc_obj = Fernet(workerStateTracker
                                         .workerState[_temp][&#34;pri_key&#34;])
                        workerStateTracker.getWorkerSocket(_temp)\
                            .sendall(enc_obj.encrypt(protocolMsg.encode()))

                        master.PRINT_LOCK.acquire()
                        print(f&#34;Sending task to worker: {protocolMsg}&#34;)
                        master.PRINT_LOCK.release()

                        workerStateTracker.allocateSlot(_temp)

                        master.PRINT_LOCK.acquire()
                        workerStateTracker.showWorkerStates()
                        master.PRINT_LOCK.release()

                        master.PRINT_LOCK.acquire()
                        print(f&#34;{requestHandler.jobRequests=}&#34;)
                        master.PRINT_LOCK.release()

                        # We have found a worker and hence set this to True
                        workerFound = True

                    workerStateTracker.LOCK.release()

                    # In the case where none of the workers have a free slot
                    if list(workerIDsVisited) == workerStateTracker.workerIDs:
                        # Sleep for a second to allow for the
                        # workerStateTracker to be updated by the
                        # thread: workerUpdates
                        time.sleep(1)

                        # Clear the worker IDs visited set as we are
                        # restarting our search for a free slot on one of the
                        # workers
                        workerIDsVisited.clear()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="src.Scheduler.RandomScheduling.RandomScheduler.jobDispatcher"><code class="name flex">
<span>def <span class="ident">jobDispatcher</span></span>(<span>requestHandler: Scheduler.JobRequests.JobRequestHandler, workerStateTracker: MasterUtils.WorkerStateTracker.StateTracker)</span>
</code></dt>
<dd>
<div class="desc"><p><code>jobDispatcher</code> implements the <strong>Random Scheduling</strong> algorithm</p>
<p><strong>param</strong> <code>requestHandler</code>: This object will track the tasks of
incomplete jobs, and provide them for allocation, respecting the
<em>map-reduce</em> dependency</p>
<p><strong>type</strong> <code>requestHandler</code>: JobRequestHandler</p>
<p><strong>param</strong> <code>workerStateTracker</code>: This object will track and update
how loaded the workers are, i.e. how many free slots fo they have</p>
<p><strong>type</strong> <code>workerStateTracker</code>: StateTracker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def jobDispatcher(requestHandler: JobRequestHandler,
                  workerStateTracker: StateTracker):
    &#34;&#34;&#34;```jobDispatcher``` implements the **Random Scheduling** algorithm

    **param** ```requestHandler```: This object will track the tasks of
    incomplete jobs, and provide them for allocation, respecting the
    *map-reduce* dependency

    **type** ```requestHandler```: JobRequestHandler

    **param** ```workerStateTracker```: This object will track and update
    how loaded the workers are, i.e. how many free slots fo they have

    **type** ```workerStateTracker```: StateTracker
    &#34;&#34;&#34;
    #  Initialize the random number generator.
    random.seed()
    workerIDsVisited: Set = set()

    while True:
        jobID_family_task = None

        # Get a pending task, if any
        requestHandler.LOCK.acquire()
        if not requestHandler.isEmpty():
            jobID_family_task = requestHandler.getWaitingTask()
        requestHandler.LOCK.release()

        # If there is a Task that needs to be executed
        if jobID_family_task is not None:
            # Initially we have not visited any worker
            workerIDsVisited.clear()

            # Initially we have not found a worker with a free slot
            workerFound: bool = False

            while workerFound is False:  # Until a free worker is not found
                workerStateTracker.LOCK.acquire()

                # Pick a worker at random
                _temp = random.choice(workerStateTracker.workerIDs)
                workerIDsVisited.add(_temp)

                # If the worker has a free slot
                if workerStateTracker.isWorkerFree(_temp):
                    # Create the JSON protocol message
                    protocolMsg = (YACS_Protocol
                                   .createMessageToWorker
                                   (
                                    job_ID=jobID_family_task[0],
                                    task_family=jobID_family_task[1],
                                    task_ID=(jobID_family_task[2]
                                             [&#34;task_id&#34;]),
                                    duration=(jobID_family_task[2]
                                              [&#34;duration&#34;]),
                                    # We only get _temp in the LOCK
                                    # i.e. critical section
                                    worker_ID=_temp
                                    ))
                    # Once a worker with a free slot is found then
                    # 1. We dispatch the job to the worker
                    # 2. Update its state
                    enc_obj = Fernet(workerStateTracker
                                     .workerState[_temp][&#34;pri_key&#34;])
                    workerStateTracker.getWorkerSocket(_temp)\
                        .sendall(enc_obj.encrypt(protocolMsg.encode()))

                    master.PRINT_LOCK.acquire()
                    print(f&#34;Sending task to worker: {protocolMsg}&#34;)
                    master.PRINT_LOCK.release()

                    workerStateTracker.allocateSlot(_temp)

                    master.PRINT_LOCK.acquire()
                    workerStateTracker.showWorkerStates()
                    master.PRINT_LOCK.release()

                    master.PRINT_LOCK.acquire()
                    print(f&#34;{requestHandler.jobRequests=}&#34;)
                    master.PRINT_LOCK.release()

                    # We have found a worker and hence set this to True
                    workerFound = True

                workerStateTracker.LOCK.release()

                # In the case where none of the workers have a free slot
                if list(workerIDsVisited) == workerStateTracker.workerIDs:
                    # Sleep for a second to allow for the
                    # workerStateTracker to be updated by the
                    # thread: workerUpdates
                    time.sleep(1)

                    # Clear the worker IDs visited set as we are
                    # restarting our search for a free slot on one of the
                    # workers
                    workerIDsVisited.clear()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Scheduler" href="index.html">src.Scheduler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Scheduler.RandomScheduling.RandomScheduler" href="#src.Scheduler.RandomScheduling.RandomScheduler">RandomScheduler</a></code></h4>
<ul class="">
<li><code><a title="src.Scheduler.RandomScheduling.RandomScheduler.jobDispatcher" href="#src.Scheduler.RandomScheduling.RandomScheduler.jobDispatcher">jobDispatcher</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>