<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>src.Analytics.analysis API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Analytics.analysis</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


def graph_plot(df, ax, title):
    &#34;&#34;&#34;
    * This function takes in the *workers.csv* for each algorithm separately
    and groups by worker id.
    * For each worker, the number of tasks running at each second in a time
    interval are calculated.
    * There are 3 plots displayed in a window, with a plot each for a
    scheduling algorithm. The X axis has the number of tasks and the Y axis
    has the time in seconds.
    * For a given scheduling algorithm, each worker is represented with a line
    of a different colour.
    &#34;&#34;&#34;
    splits1 = list(df.groupby(&#34;WorkerID&#34;))
    for i in range(len(splits1)):
        time = dict()
        a = pd.DataFrame(splits1[i][1],
                         columns=[&#39;JobId&#39;, &#39;WorkerID&#39;, &#39;TaskId&#39;,
                                  &#39;start_time&#39;, &#39;end_time&#39;, &#39;duration&#39;])
        end_time = a[&#34;end_time&#34;].iloc[-1]
        for m in range(0, end_time):
            count = 0
            for n in range(len(a[&#34;TaskId&#34;])):
                if m &gt;= a[&#34;start_time&#34;].iloc[n] and m &lt;= a[&#34;end_time&#34;].iloc[n]:
                    count = count + 1
                else:
                    pass
            time[m] = count
        label = &#34;Worker&#34; + &#34;:&#34;+str(splits1[i][0])
        x = list(time.keys())
        y = list(time.values())
        ax.set_xlabel(&#39;Time&#39;)
        ax.set_ylabel(&#39;Number of tasks&#39;)
        ax.plot(x, y, marker=&#34;o&#34;, label=label)
        ax.set_title(title)
        ax.legend()


def get_analytics():
    &#34;&#34;&#34;
    * This function reads all the log files generated for each scheduling
    algorithm.
    * The objective of this function is to calculate the mean task completion
    time, mean job completion time, median task completion time, median job
    completion time for each of the scheduling algorithms separately.
    * Various bar plots are plotted comparing the mean and median times of the
    various scheduling algorithms.
    * This function also calls the graph_plot function for each of the
    scheduling algorithms that plots the number of tasks scheduled on each
    worker at each instance of time.
    &#34;&#34;&#34;
    fig, (ax1, ax2, ax3) = plt.subplots(3, figsize=(15, 25))
    fig.tight_layout(pad=10.0)
    mean_salgo1_task = 0
    mean_salgo2_task = 0
    mean_salgo3_task = 0
    mean_salgo1_job = 0
    mean_salgo2_job = 0
    mean_salgo3_job = 0
    median_salgo1_task = 0 
    median_salgo2_task = 0
    median_salgo3_task = 0 
    median_salgo1_job = 0
    median_salgo2_job = 0
    median_salgo3_job = 0
    &#39;&#39;&#39;
    Checking if the log files for Round Robin Algorithm exist.
    If they exist perform the necessary statistical computation and plot
    the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Round-Robin&#39;):
        algo = &#39;Round-Robin&#39;
        job1 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task1 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker1 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w1 = pd.DataFrame(worker1)
        df1_j1 = pd.DataFrame(job1)
        df1_t1 = pd.DataFrame(task1)

        mean_salgo1_task = df1_t1[&#34;duration&#34;].mean()
        mean_salgo1_job = df1_j1[&#34;duration&#34;].mean()
        median_salgo1_task = df1_t1[&#34;duration&#34;].median()
        median_salgo1_job = df1_j1[&#34;duration&#34;].median()

        graph_plot(df1_w1, ax1, &#39;Round Robin Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    Checking if the log files for Least Loaded Algorithm exist.
    If they exist perform the necessary statistical computation and plot the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Least-Loaded&#39;):
        algo = &#39;Least-Loaded&#39;
        job2 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task2 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker2 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w2 = pd.DataFrame(worker2)
        df1_j2 = pd.DataFrame(job2)
        df1_t2 = pd.DataFrame(task2)

        mean_salgo2_task = df1_t2[&#34;duration&#34;].mean()
        mean_salgo2_job = df1_j2[&#34;duration&#34;].mean()
        median_salgo2_task = df1_t2[&#34;duration&#34;].median()
        median_salgo2_job = df1_j2[&#34;duration&#34;].median()

        graph_plot(df1_w2, ax2, &#39;Least Loaded Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    Checking if the log files for Random Algorithm exist.
    If they exist perform the necessary statistical computation and plot the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Random&#39;):
        algo = &#39;Random&#39;
        job3 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task3 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker3 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w3 = pd.DataFrame(worker3)
        df1_j3 = pd.DataFrame(job3)
        df1_t3 = pd.DataFrame(task3)

        mean_salgo3_task = df1_t3[&#34;duration&#34;].mean()
        mean_salgo3_job = df1_j3[&#34;duration&#34;].mean()
        median_salgo3_task = df1_t3[&#34;duration&#34;].median()
        median_salgo3_job = df1_j3[&#34;duration&#34;].median()

        graph_plot(df1_w3, ax3, &#39;Random Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    The 3 blocks of code given below display the computed mean and median
    values for each algorithm(if that algorithm was used) in a neat readable 
    format which can be used to easily read the data plotted in a graph format.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Round-Robin&#39;):
        print(&#34;\nRound-Robin Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo1_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo1_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo1_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo1_job}\n&#34;)  
    else:
        pass

    if os.path.exists(&#39;Least-Loaded&#39;):
        print(&#34;\nLeast-Loaded Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo2_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo2_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo2_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo2_job}\n&#34;)
    else:
        pass

    if os.path.exists(&#39;Random&#39;):
        print(&#34;\nRandom Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo3_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo3_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo3_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo3_job}\n&#34;)    
    else:
        pass

    &#39;&#39;&#39; Plotting bar graph to compare mean times of scheduling algorithms&#39;&#39;&#39;
    barWidth = 0.25
    fig = plt.figure(figsize=(10, 5))
    x1 = []
    y1 = []
    y2 = []
    y1.append(mean_salgo1_task)
    y1.append(mean_salgo2_task)
    y1.append(mean_salgo3_task)

    y2.append(mean_salgo1_job)
    y2.append(mean_salgo2_job)
    y2.append(mean_salgo3_job)

    x1.append(&#39;Round Robin Scheduling&#39;)
    x1.append(&#39;Least Loaded Scheduling&#39;)
    x1.append(&#39;Random Scheduling&#39;)

    br1 = np.arange(len(x1))
    br2 = [x + barWidth for x in br1] 
    plt.bar(br1, y1, color=&#39;r&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Tasks&#39;) 
    plt.bar(br2, y2, color=&#39;g&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Jobs&#39;) 
    plt.xlabel(&#39;Scheduling algorithms&#39;)
    plt.ylabel(&#39;Average task and job completion time&#39;)
    plt.xticks([r + barWidth for r in range(len(x1))], x1)
    plt.legend()

    &#39;&#39;&#39; Plotting bar graph to compare median times of scheduling algorithms&#39;&#39;&#39;
    barWidth = 0.25
    fig2 = plt.figure(figsize=(10, 5))
    x1 = []
    y1 = []
    y2 = []
    y1.append(median_salgo1_task)
    y1.append(median_salgo2_task)
    y1.append(median_salgo3_task)

    y2.append(median_salgo1_job)
    y2.append(median_salgo2_job)
    y2.append(median_salgo3_job)

    x1.append(&#39;Round Robin Scheduling&#39;)
    x1.append(&#39;Least Loaded Scheduling&#39;)
    x1.append(&#39;Random Scheduling&#39;)

    br1 = np.arange(len(x1))
    br2 = [x + barWidth for x in br1]
    plt.bar(br1, y1, color=&#39;r&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Tasks&#39;) 
    plt.bar(br2, y2, color=&#39;g&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Jobs&#39;) 
    plt.xlabel(&#39;Scheduling algorithms&#39;)
    plt.ylabel(&#39;Median task and job completion time&#39;)
    plt.xticks([r + barWidth for r in range(len(x1))], x1)
    plt.legend()


def main():
    get_analytics()


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.Analytics.analysis.get_analytics"><code class="name flex">
<span>def <span class="ident">get_analytics</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>This function reads all the log files generated for each scheduling
algorithm.</li>
<li>The objective of this function is to calculate the mean task completion
time, mean job completion time, median task completion time, median job
completion time for each of the scheduling algorithms separately.</li>
<li>Various bar plots are plotted comparing the mean and median times of the
various scheduling algorithms.</li>
<li>This function also calls the graph_plot function for each of the
scheduling algorithms that plots the number of tasks scheduled on each
worker at each instance of time.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_analytics():
    &#34;&#34;&#34;
    * This function reads all the log files generated for each scheduling
    algorithm.
    * The objective of this function is to calculate the mean task completion
    time, mean job completion time, median task completion time, median job
    completion time for each of the scheduling algorithms separately.
    * Various bar plots are plotted comparing the mean and median times of the
    various scheduling algorithms.
    * This function also calls the graph_plot function for each of the
    scheduling algorithms that plots the number of tasks scheduled on each
    worker at each instance of time.
    &#34;&#34;&#34;
    fig, (ax1, ax2, ax3) = plt.subplots(3, figsize=(15, 25))
    fig.tight_layout(pad=10.0)
    mean_salgo1_task = 0
    mean_salgo2_task = 0
    mean_salgo3_task = 0
    mean_salgo1_job = 0
    mean_salgo2_job = 0
    mean_salgo3_job = 0
    median_salgo1_task = 0 
    median_salgo2_task = 0
    median_salgo3_task = 0 
    median_salgo1_job = 0
    median_salgo2_job = 0
    median_salgo3_job = 0
    &#39;&#39;&#39;
    Checking if the log files for Round Robin Algorithm exist.
    If they exist perform the necessary statistical computation and plot
    the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Round-Robin&#39;):
        algo = &#39;Round-Robin&#39;
        job1 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task1 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker1 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w1 = pd.DataFrame(worker1)
        df1_j1 = pd.DataFrame(job1)
        df1_t1 = pd.DataFrame(task1)

        mean_salgo1_task = df1_t1[&#34;duration&#34;].mean()
        mean_salgo1_job = df1_j1[&#34;duration&#34;].mean()
        median_salgo1_task = df1_t1[&#34;duration&#34;].median()
        median_salgo1_job = df1_j1[&#34;duration&#34;].median()

        graph_plot(df1_w1, ax1, &#39;Round Robin Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    Checking if the log files for Least Loaded Algorithm exist.
    If they exist perform the necessary statistical computation and plot the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Least-Loaded&#39;):
        algo = &#39;Least-Loaded&#39;
        job2 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task2 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker2 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w2 = pd.DataFrame(worker2)
        df1_j2 = pd.DataFrame(job2)
        df1_t2 = pd.DataFrame(task2)

        mean_salgo2_task = df1_t2[&#34;duration&#34;].mean()
        mean_salgo2_job = df1_j2[&#34;duration&#34;].mean()
        median_salgo2_task = df1_t2[&#34;duration&#34;].median()
        median_salgo2_job = df1_j2[&#34;duration&#34;].median()

        graph_plot(df1_w2, ax2, &#39;Least Loaded Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    Checking if the log files for Random Algorithm exist.
    If they exist perform the necessary statistical computation and plot the graphs to draw inferences.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Random&#39;):
        algo = &#39;Random&#39;
        job3 = pd.read_csv(os.path.join(algo, &#39;jobs.csv&#39;))
        task3 = pd.read_csv(os.path.join(algo, &#39;tasks.csv&#39;))
        worker3 = pd.read_csv(os.path.join(algo, &#39;workers.csv&#39;))

        df1_w3 = pd.DataFrame(worker3)
        df1_j3 = pd.DataFrame(job3)
        df1_t3 = pd.DataFrame(task3)

        mean_salgo3_task = df1_t3[&#34;duration&#34;].mean()
        mean_salgo3_job = df1_j3[&#34;duration&#34;].mean()
        median_salgo3_task = df1_t3[&#34;duration&#34;].median()
        median_salgo3_job = df1_j3[&#34;duration&#34;].median()

        graph_plot(df1_w3, ax3, &#39;Random Scheduling&#39;)

    else:
        pass

    &#39;&#39;&#39;
    The 3 blocks of code given below display the computed mean and median
    values for each algorithm(if that algorithm was used) in a neat readable 
    format which can be used to easily read the data plotted in a graph format.
    &#39;&#39;&#39;
    if os.path.exists(&#39;Round-Robin&#39;):
        print(&#34;\nRound-Robin Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo1_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo1_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo1_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo1_job}\n&#34;)  
    else:
        pass

    if os.path.exists(&#39;Least-Loaded&#39;):
        print(&#34;\nLeast-Loaded Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo2_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo2_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo2_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo2_job}\n&#34;)
    else:
        pass

    if os.path.exists(&#39;Random&#39;):
        print(&#34;\nRandom Scheduling Algorithm&#34;)
        print(f&#34;Mean of task completion time : {mean_salgo3_task}&#34;)
        print(f&#34;Mean of job completion time : {mean_salgo3_job}&#34;)
        print(f&#34;Median of task completion time : {median_salgo3_task}&#34;)
        print(f&#34;Median of job completion time : {median_salgo3_job}\n&#34;)    
    else:
        pass

    &#39;&#39;&#39; Plotting bar graph to compare mean times of scheduling algorithms&#39;&#39;&#39;
    barWidth = 0.25
    fig = plt.figure(figsize=(10, 5))
    x1 = []
    y1 = []
    y2 = []
    y1.append(mean_salgo1_task)
    y1.append(mean_salgo2_task)
    y1.append(mean_salgo3_task)

    y2.append(mean_salgo1_job)
    y2.append(mean_salgo2_job)
    y2.append(mean_salgo3_job)

    x1.append(&#39;Round Robin Scheduling&#39;)
    x1.append(&#39;Least Loaded Scheduling&#39;)
    x1.append(&#39;Random Scheduling&#39;)

    br1 = np.arange(len(x1))
    br2 = [x + barWidth for x in br1] 
    plt.bar(br1, y1, color=&#39;r&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Tasks&#39;) 
    plt.bar(br2, y2, color=&#39;g&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Jobs&#39;) 
    plt.xlabel(&#39;Scheduling algorithms&#39;)
    plt.ylabel(&#39;Average task and job completion time&#39;)
    plt.xticks([r + barWidth for r in range(len(x1))], x1)
    plt.legend()

    &#39;&#39;&#39; Plotting bar graph to compare median times of scheduling algorithms&#39;&#39;&#39;
    barWidth = 0.25
    fig2 = plt.figure(figsize=(10, 5))
    x1 = []
    y1 = []
    y2 = []
    y1.append(median_salgo1_task)
    y1.append(median_salgo2_task)
    y1.append(median_salgo3_task)

    y2.append(median_salgo1_job)
    y2.append(median_salgo2_job)
    y2.append(median_salgo3_job)

    x1.append(&#39;Round Robin Scheduling&#39;)
    x1.append(&#39;Least Loaded Scheduling&#39;)
    x1.append(&#39;Random Scheduling&#39;)

    br1 = np.arange(len(x1))
    br2 = [x + barWidth for x in br1]
    plt.bar(br1, y1, color=&#39;r&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Tasks&#39;) 
    plt.bar(br2, y2, color=&#39;g&#39;, width=barWidth, edgecolor=&#39;grey&#39;, label=&#39;Jobs&#39;) 
    plt.xlabel(&#39;Scheduling algorithms&#39;)
    plt.ylabel(&#39;Median task and job completion time&#39;)
    plt.xticks([r + barWidth for r in range(len(x1))], x1)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="src.Analytics.analysis.graph_plot"><code class="name flex">
<span>def <span class="ident">graph_plot</span></span>(<span>df, ax, title)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>This function takes in the <em>workers.csv</em> for each algorithm separately
and groups by worker id.</li>
<li>For each worker, the number of tasks running at each second in a time
interval are calculated.</li>
<li>There are 3 plots displayed in a window, with a plot each for a
scheduling algorithm. The X axis has the number of tasks and the Y axis
has the time in seconds.</li>
<li>For a given scheduling algorithm, each worker is represented with a line
of a different colour.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_plot(df, ax, title):
    &#34;&#34;&#34;
    * This function takes in the *workers.csv* for each algorithm separately
    and groups by worker id.
    * For each worker, the number of tasks running at each second in a time
    interval are calculated.
    * There are 3 plots displayed in a window, with a plot each for a
    scheduling algorithm. The X axis has the number of tasks and the Y axis
    has the time in seconds.
    * For a given scheduling algorithm, each worker is represented with a line
    of a different colour.
    &#34;&#34;&#34;
    splits1 = list(df.groupby(&#34;WorkerID&#34;))
    for i in range(len(splits1)):
        time = dict()
        a = pd.DataFrame(splits1[i][1],
                         columns=[&#39;JobId&#39;, &#39;WorkerID&#39;, &#39;TaskId&#39;,
                                  &#39;start_time&#39;, &#39;end_time&#39;, &#39;duration&#39;])
        end_time = a[&#34;end_time&#34;].iloc[-1]
        for m in range(0, end_time):
            count = 0
            for n in range(len(a[&#34;TaskId&#34;])):
                if m &gt;= a[&#34;start_time&#34;].iloc[n] and m &lt;= a[&#34;end_time&#34;].iloc[n]:
                    count = count + 1
                else:
                    pass
            time[m] = count
        label = &#34;Worker&#34; + &#34;:&#34;+str(splits1[i][0])
        x = list(time.keys())
        y = list(time.values())
        ax.set_xlabel(&#39;Time&#39;)
        ax.set_ylabel(&#39;Number of tasks&#39;)
        ax.plot(x, y, marker=&#34;o&#34;, label=label)
        ax.set_title(title)
        ax.legend()</code></pre>
</details>
</dd>
<dt id="src.Analytics.analysis.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    get_analytics()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Analytics" href="index.html">src.Analytics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.Analytics.analysis.get_analytics" href="#src.Analytics.analysis.get_analytics">get_analytics</a></code></li>
<li><code><a title="src.Analytics.analysis.graph_plot" href="#src.Analytics.analysis.graph_plot">graph_plot</a></code></li>
<li><code><a title="src.Analytics.analysis.main" href="#src.Analytics.analysis.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>